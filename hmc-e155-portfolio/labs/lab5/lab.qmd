---
title: "Lab 5!"
description: "Interrupts and Motor Control"
author: "Sorin Jayaweera"
date: "8/27/2025"
categories:
  - reflection
  - labreport
draft: false
---


## Introduction
In this lab, the speed and polarity of a motor was read.

## Design and Testing Methodology

Instead of using continuous polling, three interrupts were configured. 
One was for time - every second a software iterrupt to prints the motor's speed and direction.
The other two interrupts were based off of two signals coming from the motor to read its internal state.

## Technical Documentation
Pins A1 and A2 were used (although A2 has the alias A7) to read the speed of the motor. The motor has 408 magnets per revolution internally. 
Activating on every rising and falling edge from the hall effect sensors passing those magnets yields 408 ticks/rev * 2 pulses/detection* 2 detections / tick.

### Schematic
![](/images/lab5/schematic.png)

### Flow Chart
![](/images/lab5/flowchart.png)

## Comparison to polling
At low speeds, the pulses to detect are sparse. Polling would waste system resources.
At high frequency comprable to the sampling rate of the microprocessor, polling and interrupts would be 
nearly indistinguishable - relevant functions would be continuously called. 

No technical quantatative analysis of polling vs interrupt was performed for this lab. 


## Results
The lab was successfully completed to show the speed of the motor at 1 Hz update. No polling was used - the entire system is based off of interrupts while still catching every clock edge 
and detecting polarity. This leaves free space for other programs to run. 


## AI overview

Summary: Got the code structure somewhat well, but messed up on grabbing the right pins and bit mappings. 

Output:

Great question! For quadrature encoder interfacing on the STM32L432KC, you should use the hardware encoder mode with a timer rather than basic GPIO interrupts. This is much more efficient and handles quadrature decoding automatically.
Recommended Pins
Use TIM2 in encoder mode with these pins:

PA0 (TIM2_CH1) - Pin 10 - Encoder A
PA1 (TIM2_CH2) - Pin 11 - Encoder B

These pins are adjacent on the physical package and TIM2 is a 32-bit timer, giving you a large count range.
Complete Encoder Interface Code
c#include "stm32l4xx_hal.h"

TIM_HandleTypeDef htim2;
volatile int32_t encoder_overflow_count = 0;

// Initialize TIM2 in Encoder Mode
void Encoder_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    // Enable clocks
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_TIM2_CLK_ENABLE();
    
    // Configure GPIO pins PA0 and PA1 for TIM2
    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;  // Use pullup for encoder signals
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // Configure TIM2 in Encoder Mode
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 0;
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 0xFFFFFFFF;  // 32-bit timer
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    // Encoder mode: count on both TI1 and TI2 edges
    TIM_Encoder_InitTypeDef encoderConfig = {0};
    encoderConfig.EncoderMode = TIM_ENCODERMODE_TI12;
    encoderConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
    encoderConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
    encoderConfig.IC1Prescaler = TIM_ICPSC_DIV1;
    encoderConfig.IC1Filter = 10;  // Filter to debounce
    encoderConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
    encoderConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
    encoderConfig.IC2Prescaler = TIM_ICPSC_DIV1;
    encoderConfig.IC2Filter = 10;  // Filter to debounce
    
    if (HAL_TIM_Encoder_Init(&htim2, &encoderConfig) != HAL_OK)
    {
        Error_Handler();
    }
    
    // Enable overflow/underflow interrupt (optional, for extended counting)
    __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
    
    // Start encoder interface
    HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);
    
    // Initialize counter to middle value to allow bidirectional counting
    __HAL_TIM_SET_COUNTER(&htim2, 0x80000000);
}

// Interrupt handler for overflow/underflow
void TIM2_IRQHandler(void)
{
    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET)
    {
        if (__HAL_TIM_GET_IT_SOURCE(&htim2, TIM_IT_UPDATE) != RESET)
        {
            __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);
            
            // Detect direction of overflow
            if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2))
            {
                encoder_overflow_count--;  // Underflow
            }
            else
            {
                encoder_overflow_count++;  // Overflow
            }
        }
    }
}

// Read encoder position (signed 32-bit)
int32_t Encoder_GetPosition(void)
{
    return (int32_t)__HAL_TIM_GET_COUNTER(&htim2) - 0x80000000;
}

// Read encoder position with overflow tracking (64-bit range)
int64_t Encoder_GetPositionExtended(void)
{
    int64_t position = (int64_t)encoder_overflow_count * 0x100000000LL;
    position += (int32_t)__HAL_TIM_GET_COUNTER(&htim2) - 0x80000000;
    return position;
}

// Reset encoder position to zero
void Encoder_Reset(void)
{
    __HAL_TIM_SET_COUNTER(&htim2, 0x80000000);
    encoder_overflow_count = 0;
}

// Get encoder velocity (counts per sample period)
int32_t Encoder_GetVelocity(void)
{
    static int32_t last_position = 0;
    int32_t current_position = Encoder_GetPosition();
    int32_t velocity = current_position - last_position;
    last_position = current_position;
    return velocity;
}
