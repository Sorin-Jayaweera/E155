[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Website\nGITHUB for this webpage"
  },
  {
    "objectID": "labs/lab6/lab.html#design-and-testing-methodology",
    "href": "labs/lab6/lab.html#design-and-testing-methodology",
    "title": "Lab 1 - E155 Startup",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology"
  },
  {
    "objectID": "labs/lab6/lab.html#technical-documentatoin",
    "href": "labs/lab6/lab.html#technical-documentatoin",
    "title": "Lab 1 - E155 Startup",
    "section": "Technical Documentatoin",
    "text": "Technical Documentatoin\n\nBlock Diagram\n\n\nSchematic"
  },
  {
    "objectID": "labs/lab6/lab.html#results-and-discussion",
    "href": "labs/lab6/lab.html#results-and-discussion",
    "title": "Lab 1 - E155 Startup",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation"
  },
  {
    "objectID": "labs/lab6/lab.html#conclusion",
    "href": "labs/lab6/lab.html#conclusion",
    "title": "Lab 1 - E155 Startup",
    "section": "Conclusion",
    "text": "Conclusion"
  },
  {
    "objectID": "labs/lab6/lab.html#ai-overview",
    "href": "labs/lab6/lab.html#ai-overview",
    "title": "Lab 1 - E155 Startup",
    "section": "AI overview",
    "text": "AI overview"
  },
  {
    "objectID": "labs/lab4/lab.html#design-and-testing-methodology",
    "href": "labs/lab4/lab.html#design-and-testing-methodology",
    "title": "Lab 1 - E155 Startup",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology"
  },
  {
    "objectID": "labs/lab4/lab.html#technical-documentatoin",
    "href": "labs/lab4/lab.html#technical-documentatoin",
    "title": "Lab 1 - E155 Startup",
    "section": "Technical Documentatoin",
    "text": "Technical Documentatoin\n\nBlock Diagram\n\n\nSchematic"
  },
  {
    "objectID": "labs/lab4/lab.html#results-and-discussion",
    "href": "labs/lab4/lab.html#results-and-discussion",
    "title": "Lab 1 - E155 Startup",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation"
  },
  {
    "objectID": "labs/lab4/lab.html#conclusion",
    "href": "labs/lab4/lab.html#conclusion",
    "title": "Lab 1 - E155 Startup",
    "section": "Conclusion",
    "text": "Conclusion"
  },
  {
    "objectID": "labs/lab4/lab.html#ai-overview",
    "href": "labs/lab4/lab.html#ai-overview",
    "title": "Lab 1 - E155 Startup",
    "section": "AI overview",
    "text": "AI overview"
  },
  {
    "objectID": "labs/lab2/lab.html",
    "href": "labs/lab2/lab.html",
    "title": "Lab 2 - Time Multiplexing",
    "section": "",
    "text": "Two 4 pin DIP switches are used to control HEX numbers on two seven segment displays. Time multiplexing was used such that only one look up table was needed, with each each 7 segment display being alternatively driven at 80 hz. The sum of the numbers is displayed in binary on 5 LEDS."
  },
  {
    "objectID": "labs/lab2/lab.html#introduction",
    "href": "labs/lab2/lab.html#introduction",
    "title": "Lab 2 - Time Multiplexing",
    "section": "",
    "text": "Two 4 pin DIP switches are used to control HEX numbers on two seven segment displays. Time multiplexing was used such that only one look up table was needed, with each each 7 segment display being alternatively driven at 80 hz. The sum of the numbers is displayed in binary on 5 LEDS."
  },
  {
    "objectID": "labs/lab2/lab.html#design-and-testing-methodology",
    "href": "labs/lab2/lab.html#design-and-testing-methodology",
    "title": "Lab 2 - Time Multiplexing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nA multiplexer inside the FPGA chooses between inputs in0 and in1 (4 bit numbers) and connects the chosen signal to the look up table. These two inputs are connected alternating at 80 hz. At the same 80hz clock, an enable for the left and right display are activated (only one at a time). The pins controlling the seven segment code are connected to both displays, but only the display with an active enable will show. Because they are switching at high frequency, it appears that both are displaying simultaneously - while in reality it is only one at a time.\nThis time multiplexing saves internal resources, and only uses one set of segment pins + an enable per display instead of using 7 pins per display.\nThe sum of the two binary numbers is sent to the LEDS."
  },
  {
    "objectID": "labs/lab2/lab.html#technical-documentation",
    "href": "labs/lab2/lab.html#technical-documentation",
    "title": "Lab 2 - Time Multiplexing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nBlock Diagram\n\nA single look up table is multiplexed with inputs from two inputs, alternating at 80 hz.\n\n\nSchematic\n\nThe output 7 segment control pins are fed to the inputs of both 7 segment displays. The power for each display is controlled by a PNP transistor, which connects the weak enable signal from the FPGA to a 3.3v source.\n\n\nTesting\nTwo simulations were used to verify the behavior of this system. The first checked that the sum of the two binary numbers was properly computed, and the second tested the switching functionality between two displays with the 7 segment output.\nThe following displays holding one display constant while changing the inputs for the other, and we see the display code updating on alternating inputs following the enable for that display. More tests are not screenshot,due to the sheer number (and zooming in to see the binary numbers as validatoin). \nThe following shows that the sum output from the top module is indeed the sum of the two inputs, for every combination of inputs. \nThe frequency of the clock alternating between segment 0 and 1 had to be determined and verified in situ, due to the nature of human eye to discerne which frequency was applicable.\n\n\nPhysical Design Calculations\nThere are several sensitive components on this PCB.\nThe FPGA pins can drive at most \\(\\pm\\) 8 mA of current through IO pins, at 3.3V. The 7 segment display can handle a maximum of 20 mA of current before burnout. The transistor has a 10x amplification from input current to output current - so to protect the displays that the transistors are driving, current at the base should be restricted to 2 mA.\nTo restrict current going to the PNP transistors, a 200 \\(\\Omega\\) resistor was used. There is at max a 0.4 V drop from the collector to emmitter, which. For a maximum current flow of 2 mA, this yields (\\(0.4V/0.02 mA = 200 \\Omega s\\)).\nThe LEDs have a forward voltage of 2.2V and a maximum current of 20 mA, which gives a minimum of 50 \\(\\Omega\\) resistor between the LEDs and ground to restrict current flow, as \\((3.2V - 2.2V)/(20mA) = 50 \\Omega\\). A 200 \\(\\Omega\\) resistor was used."
  },
  {
    "objectID": "labs/lab2/lab.html#results-and-discussion",
    "href": "labs/lab2/lab.html#results-and-discussion",
    "title": "Lab 2 - Time Multiplexing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n80 Hz was determined to be near the optimal frequency, where the human eye can’t distinguish any flicker, but the power is on long enough to make the led’s appear sufficiently bright.\nThe two seven segment displays were driven from a single LUT module with no visable failures, displaying the sum of the two numbers to LEDs. This lab was completed successfully."
  },
  {
    "objectID": "labs/lab2/lab.html#misc",
    "href": "labs/lab2/lab.html#misc",
    "title": "Lab 2 - Time Multiplexing",
    "section": "MISC",
    "text": "MISC\nHours spent: ~15 ( STUPID STUPID PCB SHORT ON THE RESET PIN STUPID AARGGH)"
  },
  {
    "objectID": "labs/lab2/lab.html#ai-overview",
    "href": "labs/lab2/lab.html#ai-overview",
    "title": "Lab 2 - Time Multiplexing",
    "section": "AI overview",
    "text": "AI overview\nThe output was very close to one that could work. I had to use several prompts with the thoughts and knowledge that I already had (i.e. using a single bus for the segments and an enable for power). However, when i was very detailed on how the code should work and what the end goals are (telling it to ask me questions about the design), it made something that would have saved me large amounts of time.\nThe code synthesized properly, and I am familiar with all syntax used."
  },
  {
    "objectID": "labs/lab2/lab.html#code",
    "href": "labs/lab2/lab.html#code",
    "title": "Lab 2 - Time Multiplexing",
    "section": "CODE",
    "text": "CODE\n\nTOP.sv\n// Sorin Jayaweera // 909 957 6074 // sojayaweera@g.hmc.edu // 9/6/2025\nmodule top( input logic [3:0] i0, input logic [3:0] i1, input logic reset, output logic sel, output logic nsel, output logic [6:0] segout, output logic [4:0] sum );\nHSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n\nlogic [3:0] iActive;\n\nlogic [24:0] counter = 0;\n\n// Look up table for the 7 segment displays\nsegLUT lut(.s(iActive),.seg(segout));\n\n// add the inputs and display on LEDS\nassign sum = i1+i0;\n\n// choosing which set of connections for the resource use\n// sequential logic\nalways_ff@(posedge int_osc) begin\n    \n        if(reset == 1) begin\n                iActive &lt;= 4'b0000;\n            end\n        else begin\n            iActive &lt;= sel ? i0 : i1;\n            end\n\nend\n\n// select as a slow clock logic\nalways_ff@(posedge int_osc) begin\n    if(reset) begin\n            counter &lt;= 25'b0;\n        end\n    else begin\n        counter &lt;= counter + 1'b1;\n    end\nend\n\nassign sel = counter[18];// // 1.43 hz\nassign nsel = !sel;\nendmodule\n\n\nsegLUT.sv\n// Sorin Jayaweera // 909 957 6074 // sojayaweera@g.hmc.edu // 9/6/2025 module segLUT( input logic [3:0] s, output logic [6:0] seg );\nalways_comb\n    case(s)\n        4'b0000: seg = 7'b0000001; //0\n        4'b0001: seg = 7'b1001111; //1\n        4'b0010: seg = 7'b0010010; //2\n        4'b0011: seg = 7'b0000110; //3\n        4'b0100: seg = 7'b1001100; //4\n        4'b0101: seg = 7'b0100100; //5\n        4'b0110: seg = 7'b0100000; //6\n        4'b0111: seg = 7'b0001111; //7\n        4'b1000: seg = 7'b0000000; //8\n        4'b1001: seg = 7'b0001100; //9\n        4'b1010: seg = 7'b0001000; //A\n        4'b1011: seg = 7'b1100000; //B\n        4'b1100: seg = 7'b0110001; //C\n        4'b1101: seg = 7'b1000010; //D\n        4'b1110: seg = 7'b0110000; //E\n        4'b1111: seg = 7'b0111000; //F\n\n    default\n        seg = 7'b1111111;//7'b0000000;\n    endcase\nendmodule\n\n\ntest_segs_v3.sv\n// Sorin Jayaweera // 909 957 6074 // sojayaweera@g.hmc.edu // 9/6/2025 `timescale 1ns/1ps module test_sum_v3 ( output logic [6:0] seg0, output logic [6:0] seg1, output logic seg1good, output logic seg0good, output logic [7:0] clk );\n// inputs\nlogic [3:0] i0;\nlogic [3:0] i1;\nlogic reset;\n//outputs to test\nlogic sel;\nlogic nsel;\nlogic [6:0] segout;\nlogic [4:0] sum;\n\nassign i0 = {clk[4],clk[5],clk[6],clk[7]};\nassign i1 = {clk[0],clk[1],clk[2],clk[3]};\ntop dut(i0,i1,reset,sel,nsel,segout,sum);\n\nassign seg1good = seg1 == (segout && sel) || nsel;\nassign seg0good = seg0 == (segout && nsel) || sel;\n\n\ninitial\n    begin\n            clk = 8'b0;\n    end\n\n// generate clock\nalways \n    begin\n      clk = clk + 1'b1; #1; \n      \n      if(clk == 8'b111111) begin\n            $display(\"no cases left\");\n            $stop;\n        end\n    end\n    \nalways_comb\n    case(i1)\n        4'b0000: seg1 = 7'b0000001; //0\n        4'b0001: seg1 = 7'b1001111; //1\n        4'b0010: seg1 = 7'b0010010; //2\n        4'b0011: seg1 = 7'b0000110; //3\n        4'b0100: seg1 = 7'b1001100; //4\n        4'b0101: seg1 = 7'b0100100; //5\n        4'b0110: seg1 = 7'b0100000; //6\n        4'b0111: seg1 = 7'b0001111; //7\n        4'b1000: seg1 = 7'b0000000; //8\n        4'b1001: seg1 = 7'b0001100; //9\n        4'b1010: seg1 = 7'b0001000; //A\n        4'b1011: seg1 = 7'b1100000; //B\n        4'b1100: seg1 = 7'b0110001; //C\n        4'b1101: seg1 = 7'b1000010; //D\n        4'b1110: seg1 = 7'b0110000; //E\n        4'b1111: seg1 = 7'b0111000; //F\n\n    default\n        seg1 = 7'b1111111;//7'b0000000;\n    endcase\n\n\nalways_comb\n    case(i0)\n        4'b0000: seg0 = 7'b0000001; //0\n        4'b0001: seg0 = 7'b1001111; //1\n        4'b0010: seg0 = 7'b0010010; //2\n        4'b0011: seg0 = 7'b0000110; //3\n        4'b0100: seg0 = 7'b1001100; //4\n        4'b0101: seg0 = 7'b0100100; //5\n        4'b0110: seg0 = 7'b0100000; //6\n        4'b0111: seg0 = 7'b0001111; //7\n        4'b1000: seg0 = 7'b0000000; //8\n        4'b1001: seg0 = 7'b0001100; //9\n        4'b1010: seg0 = 7'b0001000; //A\n        4'b1011: seg0 = 7'b1100000; //B\n        4'b1100: seg0 = 7'b0110001; //C\n        4'b1101: seg0 = 7'b1000010; //D\n        4'b1110: seg0 = 7'b0110000; //E\n        4'b1111: seg0 = 7'b0111000; //F\n\n    default\n        seg0 = 7'b1111111;//7'b0000000;\n    endcase\nendmodule\n\n\ntest_sum_v2.sv\n// Sorin Jayaweera // 909 957 6074 // sojayaweera@g.hmc.edu // 9/6/2025 `timescale 1ns/1ps module test_sum_v2 ( output logic good_sum, output logic [7:0] clk );\n// inputs\nlogic [3:0] i0;\nlogic [3:0] i1;\n\n//outputs to test\nlogic sel;\nlogic nsel;\nlogic [6:0] segout;\nlogic [4:0] sum;\n\n//expected output logic\nlogic [4:0] esum;\n\nassign i0 = {clk[4],clk[5],clk[6],clk[7]};\nassign i1 = {clk[0],clk[1],clk[2],clk[3]};\ntop dut(i0,i1,reset,sel,nsel,segout,sum);\n\n\n\nassign esum = i1 + i0;\nassign good_sum = i1+i0 == sum;\n\ninitial\n    begin\n            clk = 8'b0;\n    end\n    // generate clock\nalways \n    begin\n      clk = clk + 1'b1; #1; \n      \n      if(clk == 8'b111111) begin\n            $display(\"no cases left\");\n            $stop;\n        end\n    end\nendmodule"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "HI! This is Sorin J, THIS IS SO COOL! WUNDERBAR!\nBIO: I’m a nerd who loves existential crises and electronics and physics and philosophy and good books and playing music and and and and and and and ……\nahem\nWelcome to the website! &lt;3 HMC\nMy github: Github Link\nMy LinkedIn: Linkedin Link\nSome pretty flowers!    \nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "blogposts/post1/post1.html",
    "href": "blogposts/post1/post1.html",
    "title": "Blog post 1!",
    "section": "",
    "text": "Hi! Woah this is so cool! Lets figure out the possibilities of this software! ## TESTING MARKDOWN ### THIS TOO? #### HI! ##### WOAH THATS A LOT OF ‘#’ ###### AARRGGHH. 6 ‘#’! # Now lets explore latex! ## $} a^{b} $ inline \\(a^{b}\\) not in header hmmm lets try multiline \\[\n\\begin{align}\n\\text{multiline}\\\\\n\\text{multiline}\\\\\n\\text{multiline}\\\\\n\\text{multiline}\\\\  \n\\end{align}\n\\]\nWoah! Nice. Lets reflect on this: We have a super easy way to generate html and css files and make a personal website. This is huge. I’ve always wanted to do this, but never had the excuse or time - and was always way too scared. It was totally unfounded. This is awesome.\nIn blog style, this shall remain short - but welcome to the start of a fun new adventure in life. Signing off &lt;3 ~ Snow"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Blog post 1!\n\n\nInitial reflections\n\n\n\n\n\nAug 27, 2025\n\n\nSorin Jayaweera\n\n\n\n\n\n\n\n\n\n\n\n\nTesting Blog Posts 2\n\n\nHI!\n\n\n\n\n\nAug 27, 2025\n\n\nSorin Jayaweera\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blogposts/post2/post2.html",
    "href": "blogposts/post2/post2.html",
    "title": "Testing Blog Posts 2",
    "section": "",
    "text": "lab 2!\n\\(a^2\\)"
  },
  {
    "objectID": "labs/lab1/lab.html",
    "href": "labs/lab1/lab.html",
    "title": "Lab 1 - E155 Startup",
    "section": "",
    "text": "In this lab, a PCB with FPGA and MCU was assembled and used to drive a 7 segment LED display. Several onboard components were tested, in stages, ensuring proper communication between both microcontrollers and user display."
  },
  {
    "objectID": "labs/lab1/lab.html#introduction",
    "href": "labs/lab1/lab.html#introduction",
    "title": "Lab 1 - E155 Startup",
    "section": "",
    "text": "In this lab, a PCB with FPGA and MCU was assembled and used to drive a 7 segment LED display. Several onboard components were tested, in stages, ensuring proper communication between both microcontrollers and user display."
  },
  {
    "objectID": "labs/lab1/lab.html#design-and-testing-methodology",
    "href": "labs/lab1/lab.html#design-and-testing-methodology",
    "title": "Lab 1 - E155 Startup",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe tests for this project exist under two realms - simulation and hardware.\nSimulation was used to validate the functioning of the FPGA for internal logic states and response to inputs, and then uploaded to hardware based off of the HMC ENGR 155 DEV PCB.\n\nHardware tests\nThree hardware tests were conducted. The first ensured connection between the FPGA and the on-board LEDs, and the second required the FPGA to pull a pin on the MCU high, each driving led’s depending on their current state. The third test was using pins on the PCB to control a number displayed on the 7 segment display, as well as on-board LEDS to understand the internal state.\n\n\nSimulation\nThe 7 segment display code was verified first in simulation. A test bench was constructed with all user inputs (hex numbers 0 - 15), with the desired led and display states. The timing LED was not tested in simulation.\nThe simulation passed all tests.\n\n\nTestbench Simulation\nThe simulation included each possible stimulus from the user for numbers 0 - 15, as well as each case necessary to test the led status behavior.\nShown is a “main” testbench, which includes both the LED and 7 segment display. Two other testbench files were run using the same testbench framework. See all three testvector files.\n\nThe testbench concluded 15 tests with 0 errors."
  },
  {
    "objectID": "labs/lab1/lab.html#technical-documentation",
    "href": "labs/lab1/lab.html#technical-documentation",
    "title": "Lab 1 - E155 Startup",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nBlock Diagram\nThe block diagram for the 7 segment display is shown below. This describes the internal structure of the FPGA.\nThe FPGA controls the main logic, with an input binary number from from 0000 to 1111 and converts it to control for two the on board leds. It also drives a third led by a 2.4 hz clock signal.\nThe FPGA also converts the input binary number to control over the 7 segment display to show the input number in decimal form.\n\n\n\nSchematic\nThe schematic describes the assembled circuit shown below. First is a photo of the assembled circuit, then a schematic. For more detail on the PCB, see the HMC E155 Design reference: ()[https://pages.hmc.edu/brake/class/e155/fa23/assets/doc/E155%20Development%20Board%20Schematic.pdf]\n\n\n\n\nPins:\nThe pins used for the code inputs and outputs are as specified:\nInputs:\nS3: 32\n\nS2: 35\n\nS1: 31\n\nS0: 37\n\nReset: 23\nOutputs:\nseg[6]: 13 \n\nseg[5]: 18\n\nseg[4]: 19\n\nseg[3]: 11\n\nseg[2]: 6\n\nseg[1]: 9\n\nseg[0]: 44\n\nled[2]: 42\n\nled[1]: 38\n\nled[0]: 28\n\nResistor and Current Calculations\nThe Resistor was chosen to be 100 \\(\\Omega\\) s. At minimum there are 2 of them active at once, maximum 7 - both of these situations must be considered for determining the resistor specification.\nEach LED has a maximum forward voltage of 1.8V at 20mA per led, so we have a maximum of 40mA of allowed current.\nThe LEDS are all in parallel, not series. For there to actually be a voltage drop of 1.8V, there must be a 5-1.8 = 3.2v drop across the resistor that is connecting all of the components.\nThis means that the resistor should be at 3.2v / 40mA = 80 \\(\\Omega\\). For this project, I used 100 \\(\\Omega\\) s to give more room for unstable power supply, since we aren’t near the lower limit of current to light all 7 displays.\nFor more reference see spec sheet: ."
  },
  {
    "objectID": "labs/lab1/lab.html#results-and-discussion",
    "href": "labs/lab1/lab.html#results-and-discussion",
    "title": "Lab 1 - E155 Startup",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThis brief series of test showed that the hardware is working as expected; The FPGA and MCU were able to properly communicate, and a 7 segment display was properly driven. Further, a 2.4 hz clock signal was generated and used to drive an onboard LED, validated with an oscilloscope.\nAll intended tasks were completed successfully. The design could be improved to provide more consistent current supply. A ribbon cable has not yet been constructed due to insufficient supply. A 7 segment display driven by connections to a constant voltage would allow better control of LED brightness. The present setup distributes current across all leds in the 7 segment display, which decreases the brightness."
  },
  {
    "objectID": "labs/lab1/lab.html#conclusion",
    "href": "labs/lab1/lab.html#conclusion",
    "title": "Lab 1 - E155 Startup",
    "section": "Conclusion",
    "text": "Conclusion\nI was sufficiently able to generate a HEX code output on the 7 segment display, with a 2.4 hz clock signal and two other display LEDS, with the brightness on the 7 segment display being roughly consistent.\nHours spent in lab: Likely in the 20-low 30 hour range. This time was spent mixed helping other people and struggling with bugs that were unrelated to code (the programmer is so annoying). Code for reproducability is found in the Extra Resources category."
  },
  {
    "objectID": "labs/lab1/lab.html#bugs-for-lab",
    "href": "labs/lab1/lab.html#bugs-for-lab",
    "title": "Lab 1 - E155 Startup",
    "section": "Bugs for lab",
    "text": "Bugs for lab\nForce -s 1111 doesn’t work properly - we have to specify the bit width and interpretation. I.e., 4’b1111."
  },
  {
    "objectID": "labs/lab1/lab.html#ai-overview",
    "href": "labs/lab1/lab.html#ai-overview",
    "title": "Lab 1 - E155 Startup",
    "section": "AI Overview",
    "text": "AI Overview\nI decided to use Claude for the analysis, since I’ve used claude code for personal projects in the past. It failed significantly. There is likely less common documentation on system verilog and lattice radiant, since it would be a less used tool. Being more niche, there is less for the neural net to train on. The code that it generated has some semblence of sense, but picking through it there are constructions that I don’t understand (either from lack of knowledge on my part or genuine failure to make something better). I tried a couple prompts, but didn’t get any usable feedback from the generator.\nFor other coding projects, Claude code has worked phenominally. However, in this case it is a complete failure, not “understanding” the base errors that I was receiving."
  },
  {
    "objectID": "labs/lab1/lab.html#extra-resources",
    "href": "labs/lab1/lab.html#extra-resources",
    "title": "Lab 1 - E155 Startup",
    "section": "Extra Resources",
    "text": "Extra Resources\n\nCode\nFor the git, see (https://github.com/sorinjayaweera/mudd-junior/tree/master/labs/lab1) Display // Sorin Jayaweera // sojayaweera@g.hmc.edu // 8/28/2025"
  },
  {
    "objectID": "labs/lab1/lab.html#top",
    "href": "labs/lab1/lab.html#top",
    "title": "Lab 1 - E155 Startup",
    "section": "top",
    "text": "top\n(module that brings together the user input and pushes to both the 2 onboard leds, the clock signal, and the 7 segment display).\nmodule top( input logic [3:0] s, input logic reset, output logic [2:0] led, output logic [6:0] seg ); // S: User Input from DIP switches // RESET: Set the clock counter to zero // LED: On board LED display // SEG: 7 Segment display {A,B,C,D,E,F,G}\nlight_status ls(.s(s),.reset(reset),.led(led));\nssegdisp sdisp(.s(s),.seg(seg));\nendmodule\n// Control the onboard LEDS with input from the user. // one led will blink at 2.4 hz, // the other leds are status module light_status ( input logic [3:0] s, input logic reset, output logic [2:0] led ); logic lastled = 0; logic [24:0] counter = 0;\nassign led[0] = s[0] ^ s[1];\nassign led[1] = s[3] & s[2];\n\n// 24 Mhz Internal high-speed oscillator\nHSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n\nassign led[2] = counter % 2000000 &lt; 100000; // every million counts, blink led.  \n\n// Simple clock divider copied\nalways_ff @(posedge int_osc,negedge reset)\nbegin\n    if (reset == 0) begin \n        counter &lt;= 24'b0;\n        end\n        \n    else begin\n        counter &lt;= counter + 1'b1;\n    end\nend\nendmodule\n// take the user input from s as a number 0-9 and push to a seven segment display {ABCDEFG} module ssegdisp( input logic [3:0] s, output logic [6:0] seg );\nalways_comb\n    case(s)\n        4'b0000: seg &lt;= 7'b0000001; //0\n        4'b0001: seg &lt;= 7'b1001111; //1\n        4'b0010: seg &lt;= 7'b0010010; //2\n        4'b0011: seg &lt;= 7'b0000110; //3\n        4'b0100: seg &lt;= 7'b1001100; //4\n        4'b0101: seg &lt;= 7'b0100100; //5\n        4'b0110: seg &lt;= 7'b0100000; //6\n        4'b0111: seg &lt;= 7'b0001111; //7\n        4'b1000: seg &lt;= 7'b0000000; //8\n        4'b1001: seg &lt;= 7'b0001100; //9\n        4'b1010: seg &lt;= 7'b0001000; //A\n        4'b1011: seg &lt;= 7'b1100000; //B\n        4'b1100: seg &lt;= 7'b0110001; //C\n        4'b1101: seg &lt;= 7'b1000010; //D\n        4'b1110: seg &lt;= 7'b0110000; //E\n        4'b1111: seg &lt;= 7'b0111000; // F\n\n    default\n        seg &lt;= 7'b1111111;//7'b0000000;\n    endcase\nendmodule"
  },
  {
    "objectID": "labs/lab1/lab.html#testbench.sv",
    "href": "labs/lab1/lab.html#testbench.sv",
    "title": "Lab 1 - E155 Startup",
    "section": "testbench.sv",
    "text": "testbench.sv\n// Sorin Jayaweera // 8/29/2025 // 12:30 am // sojayaweera@g.hmc.edu\nmodule testbench(); logic reset; logic clk; logic [3:0] s; logic [2:0] led; logic [6:0] seg;\n// expected output parameters\nlogic [2:0] eled;\nlogic [6:0] eseg;\n\nint vectornum, errors;\n// change this bit width depending on the testvectors you are reading \nlogic [16:0] testvectors[15:0];\n\n// change this to whatever module - top, ssegdisp, or light_status\ntop dut(.s(s), .reset(reset), .led(led), .seg(seg));\n\n// generate clock\nalways \n    begin\n      clk = 1; #5; clk = 0; #5;\n    end\n\n\ninitial begin\n    \n    $display(\" reading \");\n    $readmemb(\"testvectors.tv\", testvectors); // change to the testvector name you are reading\n    vectornum = 0; errors = 0;\n    reset = 1; #23; reset = 0;\n    \n    $display(\" finished read\");\n    end\n\n always @(posedge clk) \n     begin\n        #1; {s,eled,eseg} = testvectors[vectornum]; // change this to what you want: s and eled, s and eseg, or all three\n        $display(\" %d %d %d test %d\", s,eled,eseg,vectornum);\n     end \n     // check results on falling edge of clk\n always @(negedge clk) \n     if (~reset) begin // skip during reset\n        if ({led,seg} !== {eled,eseg}) begin // change this to be the thing you want to test - led, seg, or both\n            errors = errors + 1; // GOOD\n        end\n     vectornum = vectornum + 1;\n     if (testvectors[vectornum] === 14'bx) begin //Change this to match the bitwidth\n         $display(\" %d tests completed with %d errors\", vectornum, errors); \n         $stop; \n     end \nend\nendmodule"
  },
  {
    "objectID": "labs/lab1/lab.html#test-vector-files",
    "href": "labs/lab1/lab.html#test-vector-files",
    "title": "Lab 1 - E155 Startup",
    "section": "Test Vector Files",
    "text": "Test Vector Files\n\nTestvectors.tv (overall)\nTo use these test vectors, run testbenchg.sv. Change the bit widths to match these inputs. The overall file has bitwidth 14. // This is the overall testing code to make it easier // S0 S1 S2 S3 _ LED1 LED2 _ 7Seg A B C D E F G // 0 0000_000_0000001 //1 0001_010_1001111 //2 0010_010_0010010 //3 0011_000_0000110 //4 0100_000_1001100 //5 0101_010_0100100 //6 0110_010_0100000 //7 0111_000_0001111 //8 1000_000_0000000 //9 1001_010_0001100 //A 1010_010_0001000 //B 1011_000_1100000 //C 1100_100_0110001 //D 1101_110_1000010 //E 1110_110_0110000 //F 1111_100_0111000\n\n\nONBOARD LED\n//Bitwidth 7 // LED TESTING // S0 S1 S2 S3 _ LED1 LED2 0000_000 //1 0001_010 //2 0010_010 //3 0011_000 //4 0100_000 //5 0101_010 //6 0110_010 //7 0111_000 //8 1000_000 //9 1001_010 //A 1010_010 //B 1011_000 //C 1100_100 //D 1101_110 //E 1110_110 //F 1111_100\n\n\n7 Segment Testing\n// bitwidth 11 // This is the overall testing code to make it easier // S0 S1 S2 S3 _ LED1 LED2 _ 7Seg A B C D E F G // 0 0000_0000001 //1 0001_1001111 //2 0010_0010010 //3 0011_0000110 //4 0100_1001100 //5 0101_0100100 //6 0110_0100000 //7 0111_0001111 //8 1000_0000000 //9 1001_0001100 //A 1010_0001000 //B 1011_1100000 //C 1100_0110001 //D 1101_1000010 //E 1110_0110000 //F 1111_0111000"
  },
  {
    "objectID": "labs/lab3/lab.html",
    "href": "labs/lab3/lab.html",
    "title": "Lab 3 - Keypad Debounce",
    "section": "",
    "text": "In this lab, a 16 pin keypad was used to read user input, the most recent two displays of which are shown on two seven segments. This tests the principles of debouncing and asynchrony."
  },
  {
    "objectID": "labs/lab3/lab.html#introduction",
    "href": "labs/lab3/lab.html#introduction",
    "title": "Lab 3 - Keypad Debounce",
    "section": "",
    "text": "In this lab, a 16 pin keypad was used to read user input, the most recent two displays of which are shown on two seven segments. This tests the principles of debouncing and asynchrony."
  },
  {
    "objectID": "labs/lab3/lab.html#design-and-testing-methodology",
    "href": "labs/lab3/lab.html#design-and-testing-methodology",
    "title": "Lab 3 - Keypad Debounce",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nOsilloscope traces were used to verify that the real world hold times for button press and release debounce timers matched expectation - 80 ms each.\nA testbench to simulate each module was also created."
  },
  {
    "objectID": "labs/lab3/lab.html#technical-documentation",
    "href": "labs/lab3/lab.html#technical-documentation",
    "title": "Lab 3 - Keypad Debounce",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nState Machine Debounce Logic\n\n\n\nBlock Diagram\n\n\n\nSchematic"
  },
  {
    "objectID": "labs/lab3/lab.html#testbench-simulation",
    "href": "labs/lab3/lab.html#testbench-simulation",
    "title": "Lab 3 - Keypad Debounce",
    "section": "Testbench Simulation",
    "text": "Testbench Simulation"
  },
  {
    "objectID": "labs/lab3/lab.html#results-and-discussion",
    "href": "labs/lab3/lab.html#results-and-discussion",
    "title": "Lab 3 - Keypad Debounce",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe device was constructed to hit each constraint - the keyboard has no debounce toggles and accepts user inputs, and the most recent two digits are displayed. The keypad will not accept any numbers that are pressed for the duration of another button.\nThe debounce length chosen is somewhat lengthy, and may be reduced for optimization."
  },
  {
    "objectID": "labs/lab3/lab.html#ai-overview",
    "href": "labs/lab3/lab.html#ai-overview",
    "title": "Lab 3 - Keypad Debounce",
    "section": "AI overview",
    "text": "AI overview"
  },
  {
    "objectID": "labs/lab5/lab.html#design-and-testing-methodology",
    "href": "labs/lab5/lab.html#design-and-testing-methodology",
    "title": "Lab 1 - E155 Startup",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology"
  },
  {
    "objectID": "labs/lab5/lab.html#technical-documentatoin",
    "href": "labs/lab5/lab.html#technical-documentatoin",
    "title": "Lab 1 - E155 Startup",
    "section": "Technical Documentatoin",
    "text": "Technical Documentatoin\n\nBlock Diagram\n\n\nSchematic"
  },
  {
    "objectID": "labs/lab5/lab.html#results-and-discussion",
    "href": "labs/lab5/lab.html#results-and-discussion",
    "title": "Lab 1 - E155 Startup",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation"
  },
  {
    "objectID": "labs/lab5/lab.html#conclusion",
    "href": "labs/lab5/lab.html#conclusion",
    "title": "Lab 1 - E155 Startup",
    "section": "Conclusion",
    "text": "Conclusion"
  },
  {
    "objectID": "labs/lab5/lab.html#ai-overview",
    "href": "labs/lab5/lab.html#ai-overview",
    "title": "Lab 1 - E155 Startup",
    "section": "AI overview",
    "text": "AI overview"
  },
  {
    "objectID": "labs/lab7/lab.html#design-and-testing-methodology",
    "href": "labs/lab7/lab.html#design-and-testing-methodology",
    "title": "Lab 7!",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology"
  },
  {
    "objectID": "labs/lab7/lab.html#technical-documentatoin",
    "href": "labs/lab7/lab.html#technical-documentatoin",
    "title": "Lab 7!",
    "section": "Technical Documentatoin",
    "text": "Technical Documentatoin\n\nBlock Diagram\n\n\nSchematic"
  },
  {
    "objectID": "labs/lab7/lab.html#results-and-discussion",
    "href": "labs/lab7/lab.html#results-and-discussion",
    "title": "Lab 7!",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation"
  },
  {
    "objectID": "labs/lab7/lab.html#conclusion",
    "href": "labs/lab7/lab.html#conclusion",
    "title": "Lab 7!",
    "section": "Conclusion",
    "text": "Conclusion"
  },
  {
    "objectID": "labs/lab7/lab.html#ai-overview",
    "href": "labs/lab7/lab.html#ai-overview",
    "title": "Lab 7!",
    "section": "AI overview",
    "text": "AI overview"
  }
]